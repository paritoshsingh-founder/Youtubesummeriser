<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Summary - YouTube Video Summariser</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="results-page">
    <a href="/" class="back-link">&larr; Summarise another video</a>

    <div class="results-layout">
      <div class="summary-section">
        <div id="cards-wrapper">
          <div class="cards-container">
            <button class="nav-btn nav-left" id="prev-btn">&#8249;</button>
            <div class="card" id="card">
              <div class="card-label" id="card-label">Summary</div>
              <h2 id="card-title"></h2>
              <p id="card-body"></p>
              <button class="play-btn hidden" id="play-btn">&#9654; Play this part</button>
            </div>
            <button class="nav-btn nav-right" id="next-btn">&#8250;</button>
          </div>
          <div class="dots" id="dots"></div>
        </div>
      </div>

      <div class="video-section">
        <div class="video-wrapper">
          <div id="yt-player"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    const card = document.getElementById("card");
    const cardLabel = document.getElementById("card-label");
    const cardTitle = document.getElementById("card-title");
    const cardBody = document.getElementById("card-body");
    const playBtn = document.getElementById("play-btn");
    const prevBtn = document.getElementById("prev-btn");
    const nextBtn = document.getElementById("next-btn");
    const dotsContainer = document.getElementById("dots");

    let cards = [];
    let currentIndex = 0;
    let player = null;

    // Load data from sessionStorage
    const summary = sessionStorage.getItem("summary");
    const videoUrl = sessionStorage.getItem("videoUrl");

    if (!summary) {
      window.location.href = "/";
    } else {
      cards = parseSummary(summary);
      currentIndex = 0;
      renderCard();
    }

    function extractVideoId(url) {
      if (!url) return null;
      const match = url.match(/(?:v=|\/shorts\/|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
      return match ? match[1] : null;
    }

    // YouTube IFrame Player API
    function onYouTubeIframeAPIReady() {
      const videoId = extractVideoId(videoUrl);
      if (!videoId) return;
      player = new YT.Player("yt-player", {
        width: "100%",
        height: "100%",
        videoId: videoId,
        playerVars: { rel: 0, enablejsapi: 1 },
      });
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;

    // Play button
    playBtn.addEventListener("click", () => {
      const c = cards[currentIndex];
      if (player && c.timestamp !== null) {
        player.seekTo(c.timestamp, true);
        player.playVideo();
      }
    });

    // Touch swipe support
    let touchStartX = 0;
    card.addEventListener("touchstart", (e) => {
      touchStartX = e.changedTouches[0].screenX;
    });

    card.addEventListener("touchend", (e) => {
      const diff = touchStartX - e.changedTouches[0].screenX;
      if (Math.abs(diff) > 50) {
        if (diff > 0 && currentIndex < cards.length - 1) navigate(1);
        else if (diff < 0 && currentIndex > 0) navigate(-1);
      }
    });

    // Keyboard support
    document.addEventListener("keydown", (e) => {
      if (!cards.length) return;
      if (e.key === "ArrowRight") navigate(1);
      if (e.key === "ArrowLeft") navigate(-1);
    });

    prevBtn.addEventListener("click", () => navigate(-1));
    nextBtn.addEventListener("click", () => navigate(1));

    function navigate(direction) {
      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= cards.length) return;

      const slideOut = direction > 0 ? "slide-out-left" : "slide-out-right";
      const slideIn = direction > 0 ? "slide-in-right" : "slide-in-left";

      card.classList.add(slideOut);
      setTimeout(() => {
        currentIndex = newIndex;
        renderCard();
        card.classList.remove(slideOut);
        card.classList.add(slideIn);
        setTimeout(() => card.classList.remove(slideIn), 300);
      }, 200);
    }

    function renderCard() {
      const c = cards[currentIndex];
      cardLabel.textContent = c.label;
      cardTitle.textContent = c.title;
      cardBody.textContent = c.body;

      // Show play button only for chapters with timestamps
      if (c.timestamp !== null) {
        playBtn.classList.remove("hidden");
      } else {
        playBtn.classList.add("hidden");
      }

      prevBtn.style.visibility = currentIndex === 0 ? "hidden" : "visible";
      nextBtn.style.visibility = currentIndex === cards.length - 1 ? "hidden" : "visible";

      dotsContainer.innerHTML = "";
      cards.forEach((_, i) => {
        const dot = document.createElement("span");
        dot.className = "dot" + (i === currentIndex ? " active" : "");
        dot.addEventListener("click", () => {
          currentIndex = i;
          renderCard();
        });
        dotsContainer.appendChild(dot);
      });
    }

    function parseTimestamp(str) {
      // Parse [M:SS] or [H:MM:SS] to seconds
      const match = str.match(/\[(\d+):(\d{2})(?::(\d{2}))?\]/);
      if (!match) return null;
      if (match[3]) {
        return parseInt(match[1]) * 3600 + parseInt(match[2]) * 60 + parseInt(match[3]);
      }
      return parseInt(match[1]) * 60 + parseInt(match[2]);
    }

    function stripTimestamp(str) {
      // Remove [M:SS] or [H:MM:SS] from heading
      return str.replace(/\[\d+:\d{2}(?::\d{2})?\]\s*/, "").trim();
    }

    function parseSummary(text) {
      const sections = [];
      const lines = text.split("\n");
      let summaryLines = [];
      let currentHeading = null;
      let currentTimestamp = null;
      let currentBody = [];
      let foundFirstChapter = false;
      let chapterNum = 0;

      for (const line of lines) {
        const headingMatch = line.match(/^#{1,3}\s+(.+)/) || line.match(/^\*\*(.+?)\*\*:?\s*$/);

        if (headingMatch) {
          const rawHeading = headingMatch[1].replace(/\*\*/g, "").replace(/:$/, "").trim();
          const lower = rawHeading.toLowerCase();

          // Skip meta headings
          if (lower === "summary" || lower === "chapter summaries" || lower === "chapters" || lower === "overview") {
            continue;
          }

          // This is a real chapter heading (has timestamp)
          if (!foundFirstChapter) {
            foundFirstChapter = true;
            // Everything collected so far is the summary
            const summaryBody = summaryLines.join("\n").trim();
            if (summaryBody) {
              sections.push({ label: "Summary", title: "Overview", body: summaryBody, timestamp: null });
            }
          } else if (currentHeading) {
            chapterNum++;
            sections.push({ label: "Chapter " + chapterNum, title: stripTimestamp(currentHeading), body: currentBody.join("\n").trim(), timestamp: currentTimestamp });
          }

          currentTimestamp = parseTimestamp(rawHeading);
          currentHeading = rawHeading;
          currentBody = [];
        } else {
          if (foundFirstChapter) {
            currentBody.push(line);
          } else {
            summaryLines.push(line);
          }
        }
      }

      // Push last chapter
      if (currentHeading) {
        chapterNum++;
        sections.push({ label: "Chapter " + chapterNum, title: stripTimestamp(currentHeading), body: currentBody.join("\n").trim(), timestamp: currentTimestamp });
      }

      // If no chapters found, show everything as summary
      if (sections.length === 0) {
        sections.push({ label: "Summary", title: "Overview", body: text.trim(), timestamp: null });
      }

      return sections;
    }
  </script>
</body>
</html>
